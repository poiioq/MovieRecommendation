# -*- coding: utf-8 -*-
"""Copy of recommendation_functions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NW_jXfGmDzUzLEVBmuhKPJigvAfDtMsM
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES
# TO THE CORRECT LOCATION (/kaggle/input) IN YOUR NOTEBOOK,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os

"""**1. Recommend Movie based on overall popularity**
First using the TMDB Ratings to come up with our Top Movies Chart. Use IMDB's weighted rating formula to construct the chart. Mathematically, it is represented as follows:

Weighted Rating (WR) =  v*R/(v+m)+m*C/(v+m)

where,

v is the number of votes for the movie
m is the minimum votes required to be listed in the chart
R is the average rating of the movie
C is the mean vote across the whole report

Determine m, for a movie to feature in the charts, it must have more votes than at least 95% of the movies in the list.

I will build our overall Top 250 Chart and will define a function to build charts for a particular genre.
"""
import pickle
import gzip

with gzip.open('model/similarity.pkl.gz', 'rb') as f_in:
    similarity = pickle.load(f_in)

def get_top_movies(movies_df):

    # Filter out movies that do not qualify for the chart
    qualified_movies = movies_df.copy().loc[movies_df['vote_count'] >= 98]

    # Sort movies based on the weighted rating calculated
    top_movies = qualified_movies.sort_values('weighted_rating', ascending=False).head(10)

    return top_movies


"""**2.Recommend by genres**"""

def get_movies_by_genre(selected_genre, movies_df):
    # Filter for movies that have the specific genre in their 'genres_meeting_threshold' list
    filtered_movies = movies_df[movies_df['genres_meeting_threshold'].apply(lambda x: selected_genre in x)]

    # Calculate the mean of the 'vote_average'
    C = filtered_movies['vote_average'].mean()

    # Calculate the percentile of 'vote_count'
    m = filtered_movies['vote_count'].quantile(0.85)

    # Function to calculate the weighted rating
    def weighted_rating(x, m=m, C=C):
      v = x['vote_count']
      R = x['vote_average']
      return (v / (v + m) * R) + (m / (m + v) * C)

    # Apply the weighted rating formula
    filtered_movies.loc[:, 'weighted_rating'] = filtered_movies.apply(weighted_rating, axis=1)

    # Sort movies based on the weighted rating calculated
    sorted_movies = filtered_movies.sort_values(by='weighted_rating', ascending=False).head(10)

    return sorted_movies

"""**3. Content Based Recommender**

Recommend by movie cast, crew

Crew: From the crew, we will only pick the director as our feature since the others don't contribute that much to the feel of the movie.

Cast: Choosing Cast is a little more tricky. Lesser known actors and minor roles do not really affect people's opinion of a movie. Therefore, we must only select the major characters and their respective actors. Arbitrarily we will choose the top 3 actors that appear in the credits list.
"""

def recommend_movies(title,movie_df, cosine_sim=similarity):
    if title not in movie_df['title'].values:
        return [], []
    idx = movie_df.loc[movie_df['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:21]  # Get top 10 similar movies, assuming there are at least 10 movies
    movie_indices = [i[0] for i in sim_scores if i[0] < len(movie_df)]
    similar_movies = movie_df.iloc[movie_indices]
    return similar_movies

def improved_recommend_movies(title, movie_df, cosine_sim=similarity):
    """
    Recommend movies based on the title provided, using cosine similarity scores and a weighted rating.
    """
    if title not in movie_df['title'].values:
        return [], []

    idx = movie_df.loc[movie_df['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:21]  # Get top 20 similar movies

    movie_indices = [i[0] for i in sim_scores if i[0] < len(movie_df)]
    similar_movies = movie_df.iloc[movie_indices]

    # Calculate the vote count of the 60th percentile movie
    m = similar_movies['vote_count'].quantile(0.60)

    def weighted_rating(x, m=m, C=movie_df['vote_average'].mean()):
        v = x['vote_count']
        R = x['vote_average']
        return (v / (v + m) * R) + (m / (m + v) * C)

    similar_movies.loc[:, 'weighted_rating'] = similar_movies.apply(weighted_rating, axis=1)
    top_recommendations = similar_movies.sort_values('weighted_rating', ascending=False).head(10)

    return top_recommendations


"""Collaborative Filtering

In this section, we will use a technique called Collaborative Filtering to make recommendations to Movie Watchers. Collaborative Filtering is based on the idea that users similar to a me can be used to predict how much I will like a particular product or service those users have used/experienced but I have not.

I will not be implementing Collaborative Filtering from scratch. Instead, I will use the Surprise library that used extremely powerful algorithms like Singular Value Decomposition (SVD) to minimise RMSE (Root Mean Square Error) and give great recommendations.
"""

"""Hybrid Recommend

In this section, I will try to build a simple hybrid recommender that brings together techniques we have implemented in the content based and collaborative filter based engines. This is how it will work:

Input: User ID and the Title of a Movie
Output: Similar movies sorted on the basis of expected ratings by that particular user.
"""


def hybrid(userId, title, movie_df, algo):
    print(f"Starting hybrid recommendations for User ID: {userId} and Title: {title}")

    # Get content-based recommendations
    content_recommend = recommend_movies(title, movie_df)
    content_recommend = pd.DataFrame(content_recommend)
    # Apply SVD model to predict ratings for all movies using .loc to avoid SettingWithCopyWarning
    content_recommend = content_recommend.copy()  # Ensure we work on a copy

    def predict_est(movieId):
        est = algo.predict(userId, movieId).est
        return est

    content_recommend['est'] = content_recommend['movieId'].apply(predict_est)

    # Sort movies based on the estimated ratings
    hybrid_recommend = content_recommend.sort_values('est', ascending=False)

    return hybrid_recommend

